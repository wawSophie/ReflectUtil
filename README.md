**
 * 二叉树：
 * 1、前序遍历（NLR）
 * 2、中序遍历（LNR）
 * 3、后续遍历（ZRN）
 * 4、根据先序遍历字符串创建二叉树,后序遍历
 * 5、求树的结点个数：左子树的结点个数+右子树的结点个数+1
 * 6、求叶子节点的个数：左子树的叶子节点+右子树的叶子节点
 * 7、第K层的结点个数
 * 8、查找，依次在二叉树的根，左子树，右子树中查找value，如果找到，返回结点，否则返回null
 * 9、树的深度
 * 10、二叉树的前序遍历非递归（递归改成非递归，需要借助栈）
 * 11、二叉树的中序遍历（非递归）
 * 12、二叉树的后序遍历（非递归）
 * 13、二叉树的层序遍历
 * 14、判断是否是完全二叉树
 * 15、判断两棵树是否是相同的-->思路：相当于判断树的左子树是否相同 && 树的右子树是否相同
 *         if（p==null && q==null） return true;//都为空树则相等
 *         if((p==null && q!=null) || (p!=null && q==null)){return false}//一个为空，一个不为空则不相等
 *         if(p.val!=q.val){return false} else{判断左子树和右子树是否相同}//如果结点的值不相同，则两棵树不相同
 * 16、另一棵树的子树-->给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
 * 17、判断二叉树是否是平衡二叉树
 *
 * 18、是否是对称二叉树
 * 19、根据二叉树创建字符串
 * 20、二叉树的最近公共祖先
 * 21、将二叉搜索树变成双向链表，二叉搜索树，中序遍历是一个有序的序列，
 * 22、根据前序与中序遍历创建二叉树
 *